<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="https://github.com/css/csso"

    >csso (v3.0.1)</a>
</h1>
<h4>CSSO (CSS Optimizer) is a CSS minifier with structural optimisations</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.csso">module csso</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csso.compress">
            function <span class="apidocSignatureSpan">csso.</span>compress
            <span class="apidocSignatureSpan">(ast, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csso.minify">
            function <span class="apidocSignatureSpan">csso.</span>minify
            <span class="apidocSignatureSpan">(source, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csso.minifyBlock">
            function <span class="apidocSignatureSpan">csso.</span>minifyBlock
            <span class="apidocSignatureSpan">(source, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csso.syntax.Lexer">
            function <span class="apidocSignatureSpan">csso.</span>syntax.Lexer
            <span class="apidocSignatureSpan">(config, syntax, structure)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csso.syntax.List">
            function <span class="apidocSignatureSpan">csso.</span>syntax.List
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csso.syntax.Tokenizer">
            function <span class="apidocSignatureSpan">csso.</span>syntax.Tokenizer
            <span class="apidocSignatureSpan">(source, startOffset, startLine, startColumn)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">csso.</span>syntax</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">csso.</span>syntax.Lexer.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">csso.</span>syntax.List.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">csso.</span>syntax.Tokenizer.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">csso.</span>syntax.syntax</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">csso.</span>usage</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">csso.</span>version</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.csso.syntax">module csso.syntax</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csso.syntax.Lexer">
            function <span class="apidocSignatureSpan">csso.syntax.</span>Lexer
            <span class="apidocSignatureSpan">(config, syntax, structure)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csso.syntax.List">
            function <span class="apidocSignatureSpan">csso.syntax.</span>List
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csso.syntax.Tokenizer">
            function <span class="apidocSignatureSpan">csso.syntax.</span>Tokenizer
            <span class="apidocSignatureSpan">(source, startOffset, startLine, startColumn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csso.syntax.clone">
            function <span class="apidocSignatureSpan">csso.syntax.</span>clone
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csso.syntax.createLexer">
            function <span class="apidocSignatureSpan">csso.syntax.</span>createLexer
            <span class="apidocSignatureSpan">(config)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csso.syntax.createSyntax">
            function <span class="apidocSignatureSpan">csso.syntax.</span>createSyntax
            <span class="apidocSignatureSpan">(config)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csso.syntax.fork">
            function <span class="apidocSignatureSpan">csso.syntax.</span>fork
            <span class="apidocSignatureSpan">(extension)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csso.syntax.fromPlainObject">
            function <span class="apidocSignatureSpan">csso.syntax.</span>fromPlainObject
            <span class="apidocSignatureSpan">(ast)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csso.syntax.keyword">
            function <span class="apidocSignatureSpan">csso.syntax.</span>keyword
            <span class="apidocSignatureSpan">(keyword)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csso.syntax.parse">
            function <span class="apidocSignatureSpan">csso.syntax.</span>parse
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csso.syntax.property">
            function <span class="apidocSignatureSpan">csso.syntax.</span>property
            <span class="apidocSignatureSpan">(property)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csso.syntax.toPlainObject">
            function <span class="apidocSignatureSpan">csso.syntax.</span>toPlainObject
            <span class="apidocSignatureSpan">(ast)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csso.syntax.translate">
            function <span class="apidocSignatureSpan">csso.syntax.</span>translate
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csso.syntax.translateMarkup">
            function <span class="apidocSignatureSpan">csso.syntax.</span>translateMarkup
            <span class="apidocSignatureSpan">(node, before, after)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csso.syntax.translateWithSourceMap">
            function <span class="apidocSignatureSpan">csso.syntax.</span>translateWithSourceMap
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csso.syntax.walk">
            function <span class="apidocSignatureSpan">csso.syntax.</span>walk
            <span class="apidocSignatureSpan">(root, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csso.syntax.walkDeclarations">
            function <span class="apidocSignatureSpan">csso.syntax.</span>walkDeclarations
            <span class="apidocSignatureSpan">(root, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csso.syntax.walkRules">
            function <span class="apidocSignatureSpan">csso.syntax.</span>walkRules
            <span class="apidocSignatureSpan">(root, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csso.syntax.walkRulesRight">
            function <span class="apidocSignatureSpan">csso.syntax.</span>walkRulesRight
            <span class="apidocSignatureSpan">(root, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csso.syntax.walkUp">
            function <span class="apidocSignatureSpan">csso.syntax.</span>walkUp
            <span class="apidocSignatureSpan">(root, fn)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">csso.</span>syntax</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">csso.syntax.</span>lexer</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.csso.syntax.Lexer">module csso.syntax.Lexer</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csso.syntax.Lexer.Lexer">
            function <span class="apidocSignatureSpan">csso.syntax.</span>Lexer
            <span class="apidocSignatureSpan">(config, syntax, structure)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.csso.syntax.Lexer.prototype">module csso.syntax.Lexer.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csso.syntax.Lexer.prototype.addProperty_">
            function <span class="apidocSignatureSpan">csso.syntax.Lexer.prototype.</span>addProperty_
            <span class="apidocSignatureSpan">(name, syntax)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csso.syntax.Lexer.prototype.addType_">
            function <span class="apidocSignatureSpan">csso.syntax.Lexer.prototype.</span>addType_
            <span class="apidocSignatureSpan">(name, syntax)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csso.syntax.Lexer.prototype.checkStructure">
            function <span class="apidocSignatureSpan">csso.syntax.Lexer.prototype.</span>checkStructure
            <span class="apidocSignatureSpan">(ast)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csso.syntax.Lexer.prototype.createDescriptor">
            function <span class="apidocSignatureSpan">csso.syntax.Lexer.prototype.</span>createDescriptor
            <span class="apidocSignatureSpan">(syntax)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csso.syntax.Lexer.prototype.dump">
            function <span class="apidocSignatureSpan">csso.syntax.Lexer.prototype.</span>dump
            <span class="apidocSignatureSpan">(syntaxAsAst)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csso.syntax.Lexer.prototype.getProperty">
            function <span class="apidocSignatureSpan">csso.syntax.Lexer.prototype.</span>getProperty
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csso.syntax.Lexer.prototype.getType">
            function <span class="apidocSignatureSpan">csso.syntax.Lexer.prototype.</span>getType
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csso.syntax.Lexer.prototype.matchProperty">
            function <span class="apidocSignatureSpan">csso.syntax.Lexer.prototype.</span>matchProperty
            <span class="apidocSignatureSpan">(propertyName, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csso.syntax.Lexer.prototype.matchType">
            function <span class="apidocSignatureSpan">csso.syntax.Lexer.prototype.</span>matchType
            <span class="apidocSignatureSpan">(typeName, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csso.syntax.Lexer.prototype.toString">
            function <span class="apidocSignatureSpan">csso.syntax.Lexer.prototype.</span>toString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csso.syntax.Lexer.prototype.validate">
            function <span class="apidocSignatureSpan">csso.syntax.Lexer.prototype.</span>validate
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">csso.syntax.Lexer.prototype.</span>lastMatchError</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">csso.syntax.Lexer.prototype.</span>structure</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.csso.syntax.List">module csso.syntax.List</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csso.syntax.List.List">
            function <span class="apidocSignatureSpan">csso.syntax.</span>List
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csso.syntax.List.createItem">
            function <span class="apidocSignatureSpan">csso.syntax.List.</span>createItem
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.csso.syntax.List.prototype">module csso.syntax.List.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csso.syntax.List.prototype.append">
            function <span class="apidocSignatureSpan">csso.syntax.List.prototype.</span>append
            <span class="apidocSignatureSpan">(item)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csso.syntax.List.prototype.appendData">
            function <span class="apidocSignatureSpan">csso.syntax.List.prototype.</span>appendData
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csso.syntax.List.prototype.appendList">
            function <span class="apidocSignatureSpan">csso.syntax.List.prototype.</span>appendList
            <span class="apidocSignatureSpan">(list)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csso.syntax.List.prototype.clear">
            function <span class="apidocSignatureSpan">csso.syntax.List.prototype.</span>clear
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csso.syntax.List.prototype.copy">
            function <span class="apidocSignatureSpan">csso.syntax.List.prototype.</span>copy
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csso.syntax.List.prototype.createItem">
            function <span class="apidocSignatureSpan">csso.syntax.List.prototype.</span>createItem
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csso.syntax.List.prototype.each">
            function <span class="apidocSignatureSpan">csso.syntax.List.prototype.</span>each
            <span class="apidocSignatureSpan">(fn, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csso.syntax.List.prototype.eachRight">
            function <span class="apidocSignatureSpan">csso.syntax.List.prototype.</span>eachRight
            <span class="apidocSignatureSpan">(fn, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csso.syntax.List.prototype.first">
            function <span class="apidocSignatureSpan">csso.syntax.List.prototype.</span>first
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csso.syntax.List.prototype.fromArray">
            function <span class="apidocSignatureSpan">csso.syntax.List.prototype.</span>fromArray
            <span class="apidocSignatureSpan">(array)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csso.syntax.List.prototype.getSize">
            function <span class="apidocSignatureSpan">csso.syntax.List.prototype.</span>getSize
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csso.syntax.List.prototype.insert">
            function <span class="apidocSignatureSpan">csso.syntax.List.prototype.</span>insert
            <span class="apidocSignatureSpan">(item, before)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csso.syntax.List.prototype.isEmpty">
            function <span class="apidocSignatureSpan">csso.syntax.List.prototype.</span>isEmpty
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csso.syntax.List.prototype.last">
            function <span class="apidocSignatureSpan">csso.syntax.List.prototype.</span>last
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csso.syntax.List.prototype.map">
            function <span class="apidocSignatureSpan">csso.syntax.List.prototype.</span>map
            <span class="apidocSignatureSpan">(fn, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csso.syntax.List.prototype.nextUntil">
            function <span class="apidocSignatureSpan">csso.syntax.List.prototype.</span>nextUntil
            <span class="apidocSignatureSpan">(start, fn, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csso.syntax.List.prototype.prevUntil">
            function <span class="apidocSignatureSpan">csso.syntax.List.prototype.</span>prevUntil
            <span class="apidocSignatureSpan">(start, fn, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csso.syntax.List.prototype.remove">
            function <span class="apidocSignatureSpan">csso.syntax.List.prototype.</span>remove
            <span class="apidocSignatureSpan">(item)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csso.syntax.List.prototype.some">
            function <span class="apidocSignatureSpan">csso.syntax.List.prototype.</span>some
            <span class="apidocSignatureSpan">(fn, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csso.syntax.List.prototype.toArray">
            function <span class="apidocSignatureSpan">csso.syntax.List.prototype.</span>toArray
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csso.syntax.List.prototype.toJSON">
            function <span class="apidocSignatureSpan">csso.syntax.List.prototype.</span>toJSON
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csso.syntax.List.prototype.updateCursors">
            function <span class="apidocSignatureSpan">csso.syntax.List.prototype.</span>updateCursors
            <span class="apidocSignatureSpan">(prevOld, prevNew, nextOld, nextNew)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.csso.syntax.Tokenizer">module csso.syntax.Tokenizer</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csso.syntax.Tokenizer.Tokenizer">
            function <span class="apidocSignatureSpan">csso.syntax.</span>Tokenizer
            <span class="apidocSignatureSpan">(source, startOffset, startLine, startColumn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csso.syntax.Tokenizer.CssSyntaxError">
            function <span class="apidocSignatureSpan">csso.syntax.Tokenizer.</span>CssSyntaxError
            <span class="apidocSignatureSpan">(message, source, offset, line, column)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csso.syntax.Tokenizer.cmpChar">
            function <span class="apidocSignatureSpan">csso.syntax.Tokenizer.</span>cmpChar
            <span class="apidocSignatureSpan">(testStr, offset, referenceCode)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csso.syntax.Tokenizer.cmpStr">
            function <span class="apidocSignatureSpan">csso.syntax.Tokenizer.</span>cmpStr
            <span class="apidocSignatureSpan">(testStr, start, end, referenceStr)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csso.syntax.Tokenizer.endsWith">
            function <span class="apidocSignatureSpan">csso.syntax.Tokenizer.</span>endsWith
            <span class="apidocSignatureSpan">(testStr, referenceStr)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csso.syntax.Tokenizer.findCommentEnd">
            function <span class="apidocSignatureSpan">csso.syntax.Tokenizer.</span>findCommentEnd
            <span class="apidocSignatureSpan">(source, offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csso.syntax.Tokenizer.findDecimalNumberEnd">
            function <span class="apidocSignatureSpan">csso.syntax.Tokenizer.</span>findDecimalNumberEnd
            <span class="apidocSignatureSpan">(source, offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csso.syntax.Tokenizer.findEscaseEnd">
            function <span class="apidocSignatureSpan">csso.syntax.Tokenizer.</span>findEscaseEnd
            <span class="apidocSignatureSpan">(source, offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csso.syntax.Tokenizer.findIdentifierEnd">
            function <span class="apidocSignatureSpan">csso.syntax.Tokenizer.</span>findIdentifierEnd
            <span class="apidocSignatureSpan">(source, offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csso.syntax.Tokenizer.findLastNonSpaceLocation">
            function <span class="apidocSignatureSpan">csso.syntax.Tokenizer.</span>findLastNonSpaceLocation
            <span class="apidocSignatureSpan">(scanner)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csso.syntax.Tokenizer.findNumberEnd">
            function <span class="apidocSignatureSpan">csso.syntax.Tokenizer.</span>findNumberEnd
            <span class="apidocSignatureSpan">(source, offset, allowFraction)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csso.syntax.Tokenizer.findStringEnd">
            function <span class="apidocSignatureSpan">csso.syntax.Tokenizer.</span>findStringEnd
            <span class="apidocSignatureSpan">(source, offset, quote)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csso.syntax.Tokenizer.findWhitespaceEnd">
            function <span class="apidocSignatureSpan">csso.syntax.Tokenizer.</span>findWhitespaceEnd
            <span class="apidocSignatureSpan">(source, offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csso.syntax.Tokenizer.firstCharOffset">
            function <span class="apidocSignatureSpan">csso.syntax.Tokenizer.</span>firstCharOffset
            <span class="apidocSignatureSpan">(source)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csso.syntax.Tokenizer.isHex">
            function <span class="apidocSignatureSpan">csso.syntax.Tokenizer.</span>isHex
            <span class="apidocSignatureSpan">(code)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csso.syntax.Tokenizer.isNewline">
            function <span class="apidocSignatureSpan">csso.syntax.Tokenizer.</span>isNewline
            <span class="apidocSignatureSpan">(source, offset, code)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csso.syntax.Tokenizer.isNumber">
            function <span class="apidocSignatureSpan">csso.syntax.Tokenizer.</span>isNumber
            <span class="apidocSignatureSpan">(code)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">csso.syntax.Tokenizer.</span>NAME</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">csso.syntax.Tokenizer.</span>PUNCTUATION</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">csso.syntax.Tokenizer.</span>SYMBOL_TYPE</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">csso.syntax.Tokenizer.</span>TYPE</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.csso.syntax.Tokenizer.prototype">module csso.syntax.Tokenizer.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csso.syntax.Tokenizer.prototype.consume">
            function <span class="apidocSignatureSpan">csso.syntax.Tokenizer.prototype.</span>consume
            <span class="apidocSignatureSpan">(tokenType)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csso.syntax.Tokenizer.prototype.consumeNonWS">
            function <span class="apidocSignatureSpan">csso.syntax.Tokenizer.prototype.</span>consumeNonWS
            <span class="apidocSignatureSpan">(tokenType)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csso.syntax.Tokenizer.prototype.eat">
            function <span class="apidocSignatureSpan">csso.syntax.Tokenizer.prototype.</span>eat
            <span class="apidocSignatureSpan">(tokenType)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csso.syntax.Tokenizer.prototype.eatNonWS">
            function <span class="apidocSignatureSpan">csso.syntax.Tokenizer.prototype.</span>eatNonWS
            <span class="apidocSignatureSpan">(tokenType)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csso.syntax.Tokenizer.prototype.error">
            function <span class="apidocSignatureSpan">csso.syntax.Tokenizer.prototype.</span>error
            <span class="apidocSignatureSpan">(message, offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csso.syntax.Tokenizer.prototype.expectIdentifier">
            function <span class="apidocSignatureSpan">csso.syntax.Tokenizer.prototype.</span>expectIdentifier
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csso.syntax.Tokenizer.prototype.getLocation">
            function <span class="apidocSignatureSpan">csso.syntax.Tokenizer.prototype.</span>getLocation
            <span class="apidocSignatureSpan">(offset, filename)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csso.syntax.Tokenizer.prototype.getLocationRange">
            function <span class="apidocSignatureSpan">csso.syntax.Tokenizer.prototype.</span>getLocationRange
            <span class="apidocSignatureSpan">(start, end, filename)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csso.syntax.Tokenizer.prototype.getTokenValue">
            function <span class="apidocSignatureSpan">csso.syntax.Tokenizer.prototype.</span>getTokenValue
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csso.syntax.Tokenizer.prototype.getTypes">
            function <span class="apidocSignatureSpan">csso.syntax.Tokenizer.prototype.</span>getTypes
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csso.syntax.Tokenizer.prototype.lookupNonWSType">
            function <span class="apidocSignatureSpan">csso.syntax.Tokenizer.prototype.</span>lookupNonWSType
            <span class="apidocSignatureSpan">(offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csso.syntax.Tokenizer.prototype.lookupType">
            function <span class="apidocSignatureSpan">csso.syntax.Tokenizer.prototype.</span>lookupType
            <span class="apidocSignatureSpan">(offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csso.syntax.Tokenizer.prototype.lookupValue">
            function <span class="apidocSignatureSpan">csso.syntax.Tokenizer.prototype.</span>lookupValue
            <span class="apidocSignatureSpan">(offset, referenceStr)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csso.syntax.Tokenizer.prototype.next">
            function <span class="apidocSignatureSpan">csso.syntax.Tokenizer.prototype.</span>next
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csso.syntax.Tokenizer.prototype.setSource">
            function <span class="apidocSignatureSpan">csso.syntax.Tokenizer.prototype.</span>setSource
            <span class="apidocSignatureSpan">(source, startOffset, startLine, startColumn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csso.syntax.Tokenizer.prototype.skip">
            function <span class="apidocSignatureSpan">csso.syntax.Tokenizer.prototype.</span>skip
            <span class="apidocSignatureSpan">(tokenCount)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csso.syntax.Tokenizer.prototype.skipSC">
            function <span class="apidocSignatureSpan">csso.syntax.Tokenizer.prototype.</span>skipSC
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csso.syntax.Tokenizer.prototype.skipWS">
            function <span class="apidocSignatureSpan">csso.syntax.Tokenizer.prototype.</span>skipWS
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csso.syntax.Tokenizer.prototype.substrToCursor">
            function <span class="apidocSignatureSpan">csso.syntax.Tokenizer.prototype.</span>substrToCursor
            <span class="apidocSignatureSpan">(start)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.csso.syntax.syntax">module csso.syntax.syntax</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csso.syntax.syntax.Lexer">
            function <span class="apidocSignatureSpan">csso.syntax.syntax.</span>Lexer
            <span class="apidocSignatureSpan">(config, syntax, structure)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">csso.syntax.syntax.</span>grammar</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.csso.usage">module csso.usage</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.csso.usage.buildIndex">
            function <span class="apidocSignatureSpan">csso.usage.</span>buildIndex
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.csso" id="apidoc.module.csso">module csso</a></h1>


    <h2>
        <a href="#apidoc.element.csso.compress" id="apidoc.element.csso.compress">
        function <span class="apidocSignatureSpan">csso.</span>compress
        <span class="apidocSignatureSpan">(ast, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function compress(ast, options) {
    ast = ast || { type: &#x27;StyleSheet&#x27;, loc: null, children: new List() };
    options = options || {};

    var logger = typeof options.logger === &#x27;function&#x27; ? options.logger : function() {};
    var specialComments = getCommentsOption(options);
    var restructuring = getRestructureOption(options);
    var firstAtrulesAllowed = true;
    var usageData = false;
    var inputRules;
    var outputRules = new List();
    var chunk;
    var chunkNum = 1;
    var chunkRules;

    if (options.clone) {
        ast = clone(ast);
    }

    if (ast.type === &#x27;StyleSheet&#x27;) {
        inputRules = ast.children;
        ast.children = outputRules;
    } else {
        inputRules = wrapBlock(ast);
    }

    if (options.usage) {
        usageData = usageUtils.buildIndex(options.usage);
    }

    do {
        chunk = readChunk(inputRules, Boolean(specialComments));

        compressChunk(chunk.stylesheet, firstAtrulesAllowed, usageData, chunkNum++, logger);

        // structure optimisations
        if (restructuring) {
            restructureBlock(chunk.stylesheet, usageData, logger);
        }

        chunkRules = chunk.stylesheet.children;

        if (chunk.comment) {
            // add \n before comment if there is another content in outputRules
            if (!outputRules.isEmpty()) {
                outputRules.insert(List.createItem({
                    type: &#x27;Raw&#x27;,
                    value: &#x27;\n&#x27;
                }));
            }

            outputRules.insert(List.createItem(chunk.comment));

            // add \n after comment if chunk is not empty
            if (!chunkRules.isEmpty()) {
                outputRules.insert(List.createItem({
                    type: &#x27;Raw&#x27;,
                    value: &#x27;\n&#x27;
                }));
            }
        }

        if (firstAtrulesAllowed &#x26;&#x26; !chunkRules.isEmpty()) {
            var lastRule = chunkRules.last();

            if (lastRule.type !== &#x27;Atrule&#x27; ||
               (lastRule.name !== &#x27;import&#x27; &#x26;&#x26; lastRule.name !== &#x27;charset&#x27;)) {
                firstAtrulesAllowed = false;
            }
        }

        if (specialComments !== &#x27;exclamation&#x27;) {
            specialComments = false;
        }

        outputRules.appendList(chunkRules);
    } while (!inputRules.isEmpty());

    return {
        ast: ast
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```

CSSO is based on [CSSTree](https://github.com/csstree/csstree) to parse CSS into AST, AST traversal and to generate AST back to
CSS. All `CSSTree` API is available behind `syntax` field. You may minify CSS step by step:

```js
var csso = require(&#x27;csso&#x27;);
var ast = csso.syntax.parse(&#x27;.test { color: #ff0000; }&#x27;);
var compressedAst = csso.<span class="apidocCodeKeywordSpan">compress</span>(ast).ast;
var minifiedCss = csso.syntax.translate(compressedAst);

console.log(minifiedCss);
// .test{color:red}
```

&#x3e; Warning: CSSO uses early versions of CSSTree that still in active development. CSSO doesn&#x27;t guarantee API behind `syntax
` field or AST format will not change in future releases of CSSO, since it&#x27;s subject to change in CSSTree. Be carefull with
 CSSO updates if you use `syntax` API until this warning removal.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csso.minify" id="apidoc.element.csso.minify">
        function <span class="apidocSignatureSpan">csso.</span>minify
        <span class="apidocSignatureSpan">(source, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function minifyStylesheet(source, options) {
    return minify(&#x27;stylesheet&#x27;, source, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
&#x3c;!-- /MarkdownTOC --&#x3e;

Basic usage:

```js
var csso = require(&#x27;csso&#x27;);

var minifiedCss = csso.<span class="apidocCodeKeywordSpan">minify</span>(&#x27;.test { color: #ff0000; }&#x27;).css;

console.log(minifiedCss);
// .test{color:red}
```

CSSO is based on [CSSTree](https://github.com/csstree/csstree) to parse CSS into AST, AST traversal and to generate AST back to
CSS. All `CSSTree` API is available behind `syntax` field. You may minify CSS step by step:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csso.minifyBlock" id="apidoc.element.csso.minifyBlock">
        function <span class="apidocSignatureSpan">csso.</span>minifyBlock
        <span class="apidocSignatureSpan">(source, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function minifyBlock(source, options) {
    return minify(&#x27;declarationList&#x27;, source, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
- Other options are the same as for [`compress()`](#compressast-options) function.

### minifyBlock(source[, options])

The same as `minify()` but for list of declarations. Usually it&#x27;s a `style` attribute value.

```js
var result = csso.<span class="apidocCodeKeywordSpan">minifyBlock</span>(&#x27;color: rgba(255, 0, 0, 1); color: #ff0000&#x27;);

console.log(result.css);
// &#x3e; color:red
```

### compress(ast[, options])
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csso.syntax.Lexer" id="apidoc.element.csso.syntax.Lexer">
        function <span class="apidocSignatureSpan">csso.</span>syntax.Lexer
        <span class="apidocSignatureSpan">(config, syntax, structure)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">syntax.Lexer = function (config, syntax, structure) {
    this.valueCommonSyntax = cssWideKeywords;
    this.syntax = syntax;
    this.generic = false;
    this.properties = {};
    this.types = {};
    this.structure = structure;

    if (config) {
        if (config.generic) {
            this.generic = true;
            for (var name in generic) {
                this.addType_(name, generic[name]);
            }
        }

        if (config.types) {
            for (var name in config.types) {
                this.addType_(name, config.types[name]);
            }
        }

        if (config.properties) {
            for (var name in config.properties) {
                this.addProperty_(name, config.properties[name]);
            }
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csso.syntax.List" id="apidoc.element.csso.syntax.List">
        function <span class="apidocSignatureSpan">csso.</span>syntax.List
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">syntax.List = function () {
    this.cursor = null;
    this.head = null;
    this.tail = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csso.syntax.Tokenizer" id="apidoc.element.csso.syntax.Tokenizer">
        function <span class="apidocSignatureSpan">csso.</span>syntax.Tokenizer
        <span class="apidocSignatureSpan">(source, startOffset, startLine, startColumn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">syntax.Tokenizer = function (source, startOffset, startLine, startColumn) {
    this.offsetAndType = null;
    this.lines = null;
    this.columns = null;

    this.setSource(source || &#x27;&#x27;, startOffset, startLine, startColumn);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>
















</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.csso.syntax" id="apidoc.module.csso.syntax">module csso.syntax</a></h1>


    <h2>
        <a href="#apidoc.element.csso.syntax.Lexer" id="apidoc.element.csso.syntax.Lexer">
        function <span class="apidocSignatureSpan">csso.syntax.</span>Lexer
        <span class="apidocSignatureSpan">(config, syntax, structure)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Lexer = function (config, syntax, structure) {
    this.valueCommonSyntax = cssWideKeywords;
    this.syntax = syntax;
    this.generic = false;
    this.properties = {};
    this.types = {};
    this.structure = structure;

    if (config) {
        if (config.generic) {
            this.generic = true;
            for (var name in generic) {
                this.addType_(name, generic[name]);
            }
        }

        if (config.types) {
            for (var name in config.types) {
                this.addType_(name, config.types[name]);
            }
        }

        if (config.properties) {
            for (var name in config.properties) {
                this.addProperty_(name, config.properties[name]);
            }
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csso.syntax.List" id="apidoc.element.csso.syntax.List">
        function <span class="apidocSignatureSpan">csso.syntax.</span>List
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">List = function () {
    this.cursor = null;
    this.head = null;
    this.tail = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csso.syntax.Tokenizer" id="apidoc.element.csso.syntax.Tokenizer">
        function <span class="apidocSignatureSpan">csso.syntax.</span>Tokenizer
        <span class="apidocSignatureSpan">(source, startOffset, startLine, startColumn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Tokenizer = function (source, startOffset, startLine, startColumn) {
    this.offsetAndType = null;
    this.lines = null;
    this.columns = null;

    this.setSource(source || &#x27;&#x27;, startOffset, startLine, startColumn);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csso.syntax.clone" id="apidoc.element.csso.syntax.clone">
        function <span class="apidocSignatureSpan">csso.syntax.</span>clone
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function clone(node) {
    var result = {};

    for (var key in node) {
        var value = node[key];

        if (value) {
            if (Array.isArray(value)) {
                value = value.slice(0);
            } else if (value instanceof List) {
                value = new List().fromArray(value.map(clone));
            } else if (value.constructor === Object) {
                value = clone(value);
            }
        }

        result[key] = value;
    }

    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csso.syntax.createLexer" id="apidoc.element.csso.syntax.createLexer">
        function <span class="apidocSignatureSpan">csso.syntax.</span>createLexer
        <span class="apidocSignatureSpan">(config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createLexer = function (config) {
    return new Lexer(config, syntax, lexer.structure);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csso.syntax.createSyntax" id="apidoc.element.csso.syntax.createSyntax">
        function <span class="apidocSignatureSpan">csso.syntax.</span>createSyntax
        <span class="apidocSignatureSpan">(config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createSyntax = function (config) {
    return createSyntax(mix({}, config));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csso.syntax.fork" id="apidoc.element.csso.syntax.fork">
        function <span class="apidocSignatureSpan">csso.syntax.</span>fork
        <span class="apidocSignatureSpan">(extension)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fork = function (extension) {
    var base = mix({}, config); // copy of config
    return createSyntax(
        typeof extension === &#x27;function&#x27;
            ? extension(base, assign)
            : mix(base, extension)
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csso.syntax.fromPlainObject" id="apidoc.element.csso.syntax.fromPlainObject">
        function <span class="apidocSignatureSpan">csso.syntax.</span>fromPlainObject
        <span class="apidocSignatureSpan">(ast)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromPlainObject = function (ast) {
    walk(ast, function(node) {
        if (node.children &#x26;&#x26; node.children instanceof List === false) {
            node.children = new List().fromArray(node.children);
        }
    });

    return ast;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csso.syntax.keyword" id="apidoc.element.csso.syntax.keyword">
        function <span class="apidocSignatureSpan">csso.syntax.</span>keyword
        <span class="apidocSignatureSpan">(keyword)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getKeywordInfo(keyword) {
    if (hasOwnProperty.call(keywords, keyword)) {
        return keywords[keyword];
    }

    var name = keyword.toLowerCase();

    if (hasOwnProperty.call(keywords, name)) {
        return keywords[keyword] = keywords[name];
    }

    var vendor = !isVariable(name, 0) ? getVendorPrefix(name, 0) : &#x27;&#x27;;

    return keywords[keyword] = Object.freeze({
        vendor: vendor,
        prefix: vendor,
        name: name.substr(vendor.length)
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csso.syntax.parse" id="apidoc.element.csso.syntax.parse">
        function <span class="apidocSignatureSpan">csso.syntax.</span>parse
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parse = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// .test{color:red}
```

CSSO is based on [CSSTree](https://github.com/csstree/csstree) to parse CSS into AST, AST traversal and to generate AST back to
CSS. All `CSSTree` API is available behind `syntax` field. You may minify CSS step by step:

```js
var csso = require(&#x27;csso&#x27;);
var ast = csso.syntax.<span class="apidocCodeKeywordSpan">parse</span>(&#x27;.test { color: #ff0000; }&#x27;);
var compressedAst = csso.compress(ast).ast;
var minifiedCss = csso.syntax.translate(compressedAst);

console.log(minifiedCss);
// .test{color:red}
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csso.syntax.property" id="apidoc.element.csso.syntax.property">
        function <span class="apidocSignatureSpan">csso.syntax.</span>property
        <span class="apidocSignatureSpan">(property)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getPropertyInfo(property) {
    if (hasOwnProperty.call(properties, property)) {
        return properties[property];
    }

    var name = property;
    var hack = property[0];

    if (hack === &#x27;/&#x27; &#x26;&#x26; property[1] === &#x27;/&#x27;) {
        hack = &#x27;//&#x27;;
    } else if (hack !== &#x27;_&#x27; &#x26;&#x26;
               hack !== &#x27;*&#x27; &#x26;&#x26;
               hack !== &#x27;$&#x27; &#x26;&#x26;
               hack !== &#x27;#&#x27; &#x26;&#x26;
               hack !== &#x27;+&#x27;) {
        hack = &#x27;&#x27;;
    }

    var variable = isVariable(name, hack.length);

    if (!variable) {
        name = name.toLowerCase();
        if (hasOwnProperty.call(properties, name)) {
            return properties[property] = properties[name];
        }
    }

    var vendor = !variable ? getVendorPrefix(name, hack.length) : &#x27;&#x27;;

    return properties[property] = Object.freeze({
        hack: hack,
        vendor: vendor,
        prefix: hack + vendor,
        name: name.substr(hack.length + vendor.length),
        variable: variable
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csso.syntax.toPlainObject" id="apidoc.element.csso.syntax.toPlainObject">
        function <span class="apidocSignatureSpan">csso.syntax.</span>toPlainObject
        <span class="apidocSignatureSpan">(ast)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toPlainObject = function (ast) {
    walkUp(ast, function(node) {
        if (node.children &#x26;&#x26; node.children instanceof List) {
            node.children = node.children.toArray();
        }
    });

    return ast;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csso.syntax.translate" id="apidoc.element.csso.syntax.translate">
        function <span class="apidocSignatureSpan">csso.syntax.</span>translate
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">translate = function (node) {
    return context.generate(node);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

CSSO is based on [CSSTree](https://github.com/csstree/csstree) to parse CSS into AST, AST traversal and to generate AST back to
CSS. All `CSSTree` API is available behind `syntax` field. You may minify CSS step by step:

```js
var csso = require(&#x27;csso&#x27;);
var ast = csso.syntax.parse(&#x27;.test { color: #ff0000; }&#x27;);
var compressedAst = csso.compress(ast).ast;
var minifiedCss = csso.syntax.<span class="apidocCodeKeywordSpan">translate</span>(compressedAst);

console.log(minifiedCss);
// .test{color:red}
```

&#x3e; Warning: CSSO uses early versions of CSSTree that still in active development. CSSO doesn&#x27;t guarantee API behind `syntax
` field or AST format will not change in future releases of CSSO, since it&#x27;s subject to change in CSSTree. Be carefull with
 CSSO updates if you use `syntax` API until this warning removal.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csso.syntax.translateMarkup" id="apidoc.element.csso.syntax.translateMarkup">
        function <span class="apidocSignatureSpan">csso.syntax.</span>translateMarkup
        <span class="apidocSignatureSpan">(node, before, after)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">translateMarkup = function (node, before, after) {
    function walk(node, buffer) {
        var value = node.value;

        before(node.node, buffer, value);

        if (typeof value === &#x27;string&#x27;) {
            buffer += value;
        } else {
            for (var i = 0; i &#x3c; value.length; i++) {
                if (typeof value[i] === &#x27;string&#x27;) {
                    buffer += value[i];
                } else {
                    buffer = walk(value[i], buffer);
                }
            }
        }

        after(node.node, buffer, value);

        return buffer;
    }

    if (typeof before !== &#x27;function&#x27;) {
        before = function() {};
    }
    if (typeof after !== &#x27;function&#x27;) {
        after = function() {};
    }

    return walk(context.generate(node), &#x27;&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csso.syntax.translateWithSourceMap" id="apidoc.element.csso.syntax.translateWithSourceMap">
        function <span class="apidocSignatureSpan">csso.syntax.</span>translateWithSourceMap
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">translateWithSourceMap = function (node) {
    return sourceMapGenerator(markupGenerator, node);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csso.syntax.walk" id="apidoc.element.csso.syntax.walk">
        function <span class="apidocSignatureSpan">csso.syntax.</span>walk
        <span class="apidocSignatureSpan">(root, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">walk = function (root, fn) {
    function walk(node, item, list) {
        fn.call(context, node, item, list);
        if (walkers.hasOwnProperty(node.type)) {
            walkers[node.type](node, context, walk);
        }
    }

    var context = createContext(root, fn);

    walk(root);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csso.syntax.walkDeclarations" id="apidoc.element.csso.syntax.walkDeclarations">
        function <span class="apidocSignatureSpan">csso.syntax.</span>walkDeclarations
        <span class="apidocSignatureSpan">(root, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">walkDeclarations = function (root, fn) {
    walkDeclarations.call(createContext(root, fn), root);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csso.syntax.walkRules" id="apidoc.element.csso.syntax.walkRules">
        function <span class="apidocSignatureSpan">csso.syntax.</span>walkRules
        <span class="apidocSignatureSpan">(root, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">walkRules = function (root, fn) {
    walkRules.call(createContext(root, fn), root);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csso.syntax.walkRulesRight" id="apidoc.element.csso.syntax.walkRulesRight">
        function <span class="apidocSignatureSpan">csso.syntax.</span>walkRulesRight
        <span class="apidocSignatureSpan">(root, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">walkRulesRight = function (root, fn) {
    walkRulesRight.call(createContext(root, fn), root);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csso.syntax.walkUp" id="apidoc.element.csso.syntax.walkUp">
        function <span class="apidocSignatureSpan">csso.syntax.</span>walkUp
        <span class="apidocSignatureSpan">(root, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">walkUp = function (root, fn) {
    function walk(node, item, list) {
        if (walkers.hasOwnProperty(node.type)) {
            walkers[node.type](node, context, walk);
        }
        fn.call(context, node, item, list);
    }

    var context = createContext(root, fn);

    walk(root);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.csso.syntax.Lexer" id="apidoc.module.csso.syntax.Lexer">module csso.syntax.Lexer</a></h1>


    <h2>
        <a href="#apidoc.element.csso.syntax.Lexer.Lexer" id="apidoc.element.csso.syntax.Lexer.Lexer">
        function <span class="apidocSignatureSpan">csso.syntax.</span>Lexer
        <span class="apidocSignatureSpan">(config, syntax, structure)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Lexer = function (config, syntax, structure) {
    this.valueCommonSyntax = cssWideKeywords;
    this.syntax = syntax;
    this.generic = false;
    this.properties = {};
    this.types = {};
    this.structure = structure;

    if (config) {
        if (config.generic) {
            this.generic = true;
            for (var name in generic) {
                this.addType_(name, generic[name]);
            }
        }

        if (config.types) {
            for (var name in config.types) {
                this.addType_(name, config.types[name]);
            }
        }

        if (config.properties) {
            for (var name in config.properties) {
                this.addProperty_(name, config.properties[name]);
            }
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.csso.syntax.Lexer.prototype" id="apidoc.module.csso.syntax.Lexer.prototype">module csso.syntax.Lexer.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.csso.syntax.Lexer.prototype.addProperty_" id="apidoc.element.csso.syntax.Lexer.prototype.addProperty_">
        function <span class="apidocSignatureSpan">csso.syntax.Lexer.prototype.</span>addProperty_
        <span class="apidocSignatureSpan">(name, syntax)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addProperty_ = function (name, syntax) {
    this.properties[name] = this.createDescriptor(syntax);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csso.syntax.Lexer.prototype.addType_" id="apidoc.element.csso.syntax.Lexer.prototype.addType_">
        function <span class="apidocSignatureSpan">csso.syntax.Lexer.prototype.</span>addType_
        <span class="apidocSignatureSpan">(name, syntax)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addType_ = function (name, syntax) {
    this.types[name] = this.createDescriptor(syntax);

    if (syntax === generic.expression) {
        this.valueCommonSyntax = cssWideKeywordsWithExpression;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csso.syntax.Lexer.prototype.checkStructure" id="apidoc.element.csso.syntax.Lexer.prototype.checkStructure">
        function <span class="apidocSignatureSpan">csso.syntax.Lexer.prototype.</span>checkStructure
        <span class="apidocSignatureSpan">(ast)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">checkStructure = function (ast) {
    var structure = this.structure;
    var warns = [];

    this.syntax.walk(ast, function(node) {
        if (structure.hasOwnProperty(node.type)) {
            structure[node.type].check(node, warns.push.bind(warns));
        } else {
            throw new Error(&#x27;Unknown node type: &#x27; + node.type);
        }
    });

    return warns.length ? warns : false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csso.syntax.Lexer.prototype.createDescriptor" id="apidoc.element.csso.syntax.Lexer.prototype.createDescriptor">
        function <span class="apidocSignatureSpan">csso.syntax.Lexer.prototype.</span>createDescriptor
        <span class="apidocSignatureSpan">(syntax)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createDescriptor = function (syntax) {
    var self = this;
    var descriptor = {
        syntax: null,
        match: null
    };

    if (typeof syntax === &#x27;function&#x27;) {
        descriptor.match = function(node) {
            if (node &#x26;&#x26; syntax(node)) {
                return {
                    badNode: null,
                    lastNode: null,
                    next: node.next,
                    match: [node.data]
                };
            }

            return null;
        };
    } else {
        if (typeof syntax === &#x27;string&#x27;) {
            Object.defineProperty(descriptor, &#x27;syntax&#x27;, {
                get: function() {
                    Object.defineProperty(descriptor, &#x27;syntax&#x27;, {
                        value: parse(syntax)
                    });

                    return descriptor.syntax;
                }
            });
        } else {
            descriptor.syntax = syntax;
        }

        descriptor.match = function(ast) {
            return match(self, descriptor.syntax, ast);
        };
    }

    return descriptor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csso.syntax.Lexer.prototype.dump" id="apidoc.element.csso.syntax.Lexer.prototype.dump">
        function <span class="apidocSignatureSpan">csso.syntax.Lexer.prototype.</span>dump
        <span class="apidocSignatureSpan">(syntaxAsAst)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dump = function (syntaxAsAst) {
    return {
        generic: this.generic,
        types: dumpMapSyntax(this.types, syntaxAsAst),
        properties: dumpMapSyntax(this.properties, syntaxAsAst)
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csso.syntax.Lexer.prototype.getProperty" id="apidoc.element.csso.syntax.Lexer.prototype.getProperty">
        function <span class="apidocSignatureSpan">csso.syntax.Lexer.prototype.</span>getProperty
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getProperty = function (name) {
    return this.properties.hasOwnProperty(name) ? this.properties[name] : null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csso.syntax.Lexer.prototype.getType" id="apidoc.element.csso.syntax.Lexer.prototype.getType">
        function <span class="apidocSignatureSpan">csso.syntax.Lexer.prototype.</span>getType
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getType = function (name) {
    return this.types.hasOwnProperty(name) ? this.types[name] : null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csso.syntax.Lexer.prototype.matchProperty" id="apidoc.element.csso.syntax.Lexer.prototype.matchProperty">
        function <span class="apidocSignatureSpan">csso.syntax.Lexer.prototype.</span>matchProperty
        <span class="apidocSignatureSpan">(propertyName, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">matchProperty = function (propertyName, value) {
    var property = names.property(propertyName);

    // don&#x27;t match syntax for a custom property
    if (property.variable) {
        return {
            type: &#x27;NoMatch&#x27;,
            comment: &#x27;Lexer matching doesn\&#x27;t applicable for custom properties&#x27;
        };
    }

    var propertySyntax = property.vendor
        ? this.getProperty(property.vendor + property.name) || this.getProperty(property.name)
        : this.getProperty(property.name);

    if (!propertySyntax) {
        this.lastMatchError = new Error(&#x27;Unknown property: &#x27; + propertyName);
        return null;
    }

    return matchSyntax(this, propertySyntax, value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csso.syntax.Lexer.prototype.matchType" id="apidoc.element.csso.syntax.Lexer.prototype.matchType">
        function <span class="apidocSignatureSpan">csso.syntax.Lexer.prototype.</span>matchType
        <span class="apidocSignatureSpan">(typeName, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">matchType = function (typeName, value) {
    var typeSyntax = this.getType(typeName);

    if (!typeSyntax) {
        this.lastMatchError = new Error(&#x27;Unknown type: &#x27; + typeName);
        return null;
    }

    return matchSyntax(this, typeSyntax, value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csso.syntax.Lexer.prototype.toString" id="apidoc.element.csso.syntax.Lexer.prototype.toString">
        function <span class="apidocSignatureSpan">csso.syntax.Lexer.prototype.</span>toString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toString = function () {
    return JSON.stringify(this.dump());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  filename: &#x27;path/to/my.css&#x27;, // will be added to source map as reference to source file
  sourceMap: true             // generate source map
});

console.log(result);
// { css: &#x27;...minified...&#x27;, map: SourceMapGenerator {} }

console.log(result.map.<span class="apidocCodeKeywordSpan">toString</span>());
// &#x27;{ .. source map content .. }&#x27;
```

Example of generating source map with respect of source map from input CSS:

```js
var require(&#x27;source-map&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csso.syntax.Lexer.prototype.validate" id="apidoc.element.csso.syntax.Lexer.prototype.validate">
        function <span class="apidocSignatureSpan">csso.syntax.Lexer.prototype.</span>validate
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validate = function () {
    function validate(syntax, name, broken, descriptor) {
        if (broken.hasOwnProperty(name)) {
            return broken[name];
        }

        broken[name] = false;
        if (descriptor.syntax !== null) {
            walk(descriptor.syntax, function(node) {
                if (node.type !== &#x27;Type&#x27; &#x26;&#x26; node.type !== &#x27;Property&#x27;) {
                    return;
                }

                var map = node.type === &#x27;Type&#x27; ? syntax.types : syntax.properties;
                var brokenMap = node.type === &#x27;Type&#x27; ? brokenTypes : brokenProperties;

                if (!map.hasOwnProperty(node.name) || validate(syntax, node.name, brokenMap, map[node.name])) {
                    broken[name] = true;
                }
            }, this);
        }
    }

    var brokenTypes = {};
    var brokenProperties = {};

    for (var key in this.types) {
        validate(this, key, brokenTypes, this.types[key]);
    }

    for (var key in this.properties) {
        validate(this, key, brokenProperties, this.properties[key]);
    }

    brokenTypes = Object.keys(brokenTypes).filter(function(name) {
        return brokenTypes[name];
    });
    brokenProperties = Object.keys(brokenProperties).filter(function(name) {
        return brokenProperties[name];
    });

    if (brokenTypes.length || brokenProperties.length) {
        return {
            types: brokenTypes,
            properties: brokenProperties
        };
    }

    return null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.csso.syntax.List" id="apidoc.module.csso.syntax.List">module csso.syntax.List</a></h1>


    <h2>
        <a href="#apidoc.element.csso.syntax.List.List" id="apidoc.element.csso.syntax.List.List">
        function <span class="apidocSignatureSpan">csso.syntax.</span>List
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">List = function () {
    this.cursor = null;
    this.head = null;
    this.tail = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csso.syntax.List.createItem" id="apidoc.element.csso.syntax.List.createItem">
        function <span class="apidocSignatureSpan">csso.syntax.List.</span>createItem
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createItem(data) {
    return {
        prev: null,
        next: null,
        data: data
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        }

        chunkRules = chunk.stylesheet.children;

        if (chunk.comment) {
// add \n before comment if there is another content in outputRules
if (!outputRules.isEmpty()) {
    outputRules.insert(List.<span class="apidocCodeKeywordSpan">createItem</span>({
        type: &#x27;Raw&#x27;,
        value: &#x27;\n&#x27;
    }));
}

outputRules.insert(List.createItem(chunk.comment));
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.csso.syntax.List.prototype" id="apidoc.module.csso.syntax.List.prototype">module csso.syntax.List.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.csso.syntax.List.prototype.append" id="apidoc.element.csso.syntax.List.prototype.append">
        function <span class="apidocSignatureSpan">csso.syntax.List.prototype.</span>append
        <span class="apidocSignatureSpan">(item)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">append = function (item) {
    // tail
    //      ^
    //     item
    this.updateCursors(this.tail, item, null, item);

    // insert to end of the list
    if (this.tail !== null) {
        // if list has a tail, then it also has a head, but head doesn&#x27;t change

        // last item -&#x3e; new item
        this.tail.next = item;

        // last item &#x3c;- new item
        item.prev = this.tail;
    } else {
        // if list has no a tail, then it also has no a head
        // in this case points head to new item
        this.head = item;
    }

    // tail always start point to new item
    this.tail = item;

    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csso.syntax.List.prototype.appendData" id="apidoc.element.csso.syntax.List.prototype.appendData">
        function <span class="apidocSignatureSpan">csso.syntax.List.prototype.</span>appendData
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">appendData = function (data) {
    return this.append(createItem(data));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
function getRestructureOption(options) {
return &#x27;restructure&#x27; in options ? options.restructure :
       &#x27;restructuring&#x27; in options ? options.restructuring :
       true;
}

function wrapBlock(block) {
return new List().<span class="apidocCodeKeywordSpan">appendData</span>({
    type: &#x27;Rule&#x27;,
    selector: {
        type: &#x27;SelectorList&#x27;,
        children: new List().appendData({
            type: &#x27;Selector&#x27;,
            children: new List().appendData({
                type: &#x27;Identifier&#x27;,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csso.syntax.List.prototype.appendList" id="apidoc.element.csso.syntax.List.prototype.appendList">
        function <span class="apidocSignatureSpan">csso.syntax.List.prototype.</span>appendList
        <span class="apidocSignatureSpan">(list)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">appendList = function (list) {
    // ignore empty lists
    if (list.head === null) {
        return;
    }

    this.updateCursors(this.tail, list.tail, null, list.head);

    // insert to end of the list
    if (this.tail !== null) {
        // if destination list has a tail, then it also has a head,
        // but head doesn&#x27;t change

        // dest tail -&#x3e; source head
        this.tail.next = list.head;

        // dest tail &#x3c;- source head
        list.head.prev = this.tail;
    } else {
        // if list has no a tail, then it also has no a head
        // in this case points head to new item
        this.head = list.head;
    }

    // tail always start point to new item
    this.tail = list.tail;

    list.head = null;
    list.tail = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            }
        }

        if (specialComments !== &#x27;exclamation&#x27;) {
            specialComments = false;
        }

        outputRules.<span class="apidocCodeKeywordSpan">appendList</span>(chunkRules);
    } while (!inputRules.isEmpty());

    return {
        ast: ast
    };
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csso.syntax.List.prototype.clear" id="apidoc.element.csso.syntax.List.prototype.clear">
        function <span class="apidocSignatureSpan">csso.syntax.List.prototype.</span>clear
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clear = function () {
    this.head = null;
    this.tail = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csso.syntax.List.prototype.copy" id="apidoc.element.csso.syntax.List.prototype.copy">
        function <span class="apidocSignatureSpan">csso.syntax.List.prototype.</span>copy
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">copy = function () {
    var result = new List();
    var cursor = this.head;

    while (cursor !== null) {
        result.insert(createItem(cursor.data));
        cursor = cursor.next;
    }

    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csso.syntax.List.prototype.createItem" id="apidoc.element.csso.syntax.List.prototype.createItem">
        function <span class="apidocSignatureSpan">csso.syntax.List.prototype.</span>createItem
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createItem(data) {
    return {
        prev: null,
        next: null,
        data: data
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        }

        chunkRules = chunk.stylesheet.children;

        if (chunk.comment) {
// add \n before comment if there is another content in outputRules
if (!outputRules.isEmpty()) {
    outputRules.insert(List.<span class="apidocCodeKeywordSpan">createItem</span>({
        type: &#x27;Raw&#x27;,
        value: &#x27;\n&#x27;
    }));
}

outputRules.insert(List.createItem(chunk.comment));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csso.syntax.List.prototype.each" id="apidoc.element.csso.syntax.List.prototype.each">
        function <span class="apidocSignatureSpan">csso.syntax.List.prototype.</span>each
        <span class="apidocSignatureSpan">(fn, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">each = function (fn, context) {
    var item;

    if (context === undefined) {
        context = this;
    }

    // push cursor
    var cursor = allocateCursor(this, null, this.head);

    while (cursor.next !== null) {
        item = cursor.next;
        cursor.next = item.next;

        fn.call(context, item.data, item, this);
    }

    // pop cursor
    releaseCursor(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csso.syntax.List.prototype.eachRight" id="apidoc.element.csso.syntax.List.prototype.eachRight">
        function <span class="apidocSignatureSpan">csso.syntax.List.prototype.</span>eachRight
        <span class="apidocSignatureSpan">(fn, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">eachRight = function (fn, context) {
    var item;

    if (context === undefined) {
        context = this;
    }

    // push cursor
    var cursor = allocateCursor(this, this.tail, null);

    while (cursor.prev !== null) {
        item = cursor.prev;
        cursor.prev = item.prev;

        fn.call(context, item.data, item, this);
    }

    // pop cursor
    releaseCursor(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csso.syntax.List.prototype.first" id="apidoc.element.csso.syntax.List.prototype.first">
        function <span class="apidocSignatureSpan">csso.syntax.List.prototype.</span>first
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">first = function () {
    return this.head &#x26;&#x26; this.head.data;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csso.syntax.List.prototype.fromArray" id="apidoc.element.csso.syntax.List.prototype.fromArray">
        function <span class="apidocSignatureSpan">csso.syntax.List.prototype.</span>fromArray
        <span class="apidocSignatureSpan">(array)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromArray = function (array) {
    var cursor = null;

    this.head = null;

    for (var i = 0; i &#x3c; array.length; i++) {
        var item = createItem(array[i]);

        if (cursor !== null) {
            cursor.next = item;
        } else {
            this.head = item;
        }

        item.prev = cursor;
        cursor = item;
    }

    this.tail = cursor;

    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csso.syntax.List.prototype.getSize" id="apidoc.element.csso.syntax.List.prototype.getSize">
        function <span class="apidocSignatureSpan">csso.syntax.List.prototype.</span>getSize
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getSize = function () {
    var size = 0;
    var cursor = this.head;

    while (cursor) {
        size++;
        cursor = cursor.next;
    }

    return size;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csso.syntax.List.prototype.insert" id="apidoc.element.csso.syntax.List.prototype.insert">
        function <span class="apidocSignatureSpan">csso.syntax.List.prototype.</span>insert
        <span class="apidocSignatureSpan">(item, before)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">insert = function (item, before) {
    if (before !== undefined &#x26;&#x26; before !== null) {
        // prev   before
        //      ^
        //     item
        this.updateCursors(before.prev, item, before, item);

        if (before.prev === null) {
            // insert to the beginning of list
            if (this.head !== before) {
                throw new Error(&#x27;before doesn\&#x27;t below to list&#x27;);
            }

            // since head points to before therefore list doesn&#x27;t empty
            // no need to check tail
            this.head = item;
            before.prev = item;
            item.next = before;

            this.updateCursors(null, item);
        } else {

            // insert between two items
            before.prev.next = item;
            item.prev = before.prev;

            before.prev = item;
            item.next = before;
        }
    } else {
        this.append(item);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        return;
    }

    if (node.type !== &#x27;WhiteSpace&#x27;) {
        nonSpaceTokenInBuffer = true;
    }

    buffer.<span class="apidocCodeKeywordSpan">insert</span>(list.remove(item));
});

return {
    comment: protectedComment,
    stylesheet: {
        type: &#x27;StyleSheet&#x27;,
        loc: null,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csso.syntax.List.prototype.isEmpty" id="apidoc.element.csso.syntax.List.prototype.isEmpty">
        function <span class="apidocSignatureSpan">csso.syntax.List.prototype.</span>isEmpty
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isEmpty = function () {
    return this.head === null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
restructureBlock(chunk.stylesheet, usageData, logger);
        }

        chunkRules = chunk.stylesheet.children;

        if (chunk.comment) {
// add \n before comment if there is another content in outputRules
if (!outputRules.<span class="apidocCodeKeywordSpan">isEmpty</span>()) {
    outputRules.insert(List.createItem({
        type: &#x27;Raw&#x27;,
        value: &#x27;\n&#x27;
    }));
}

outputRules.insert(List.createItem(chunk.comment));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csso.syntax.List.prototype.last" id="apidoc.element.csso.syntax.List.prototype.last">
        function <span class="apidocSignatureSpan">csso.syntax.List.prototype.</span>last
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">last = function () {
    return this.tail &#x26;&#x26; this.tail.data;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            type: &#x27;Raw&#x27;,
            value: &#x27;\n&#x27;
        }));
    }
}

if (firstAtrulesAllowed &#x26;&#x26; !chunkRules.isEmpty()) {
    var lastRule = chunkRules.<span class="apidocCodeKeywordSpan">last</span>();

    if (lastRule.type !== &#x27;Atrule&#x27; ||
       (lastRule.name !== &#x27;import&#x27; &#x26;&#x26; lastRule.name !== &#x27;charset&#x27;)) {
        firstAtrulesAllowed = false;
    }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csso.syntax.List.prototype.map" id="apidoc.element.csso.syntax.List.prototype.map">
        function <span class="apidocSignatureSpan">csso.syntax.List.prototype.</span>map
        <span class="apidocSignatureSpan">(fn, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">map = function (fn, context) {
    var result = [];
    var cursor = this.head;

    if (context === undefined) {
        context = this;
    }

    while (cursor !== null) {
        result.push(fn.call(context, cursor.data, cursor, this));
        cursor = cursor.next;
    }

    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csso.syntax.List.prototype.nextUntil" id="apidoc.element.csso.syntax.List.prototype.nextUntil">
        function <span class="apidocSignatureSpan">csso.syntax.List.prototype.</span>nextUntil
        <span class="apidocSignatureSpan">(start, fn, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">nextUntil = function (start, fn, context) {
    if (start === null) {
        return;
    }

    var item;

    if (context === undefined) {
        context = this;
    }

    // push cursor
    var cursor = allocateCursor(this, null, start);

    while (cursor.next !== null) {
        item = cursor.next;
        cursor.next = item.next;

        if (fn.call(context, item.data, item, this)) {
            break;
        }
    }

    // pop cursor
    releaseCursor(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var walkRules = require(&#x27;css-tree&#x27;).walkRules;

function readChunk(children, specialComments) {
    var buffer = new List();
    var nonSpaceTokenInBuffer = false;
    var protectedComment;

    children.<span class="apidocCodeKeywordSpan">nextUntil</span>(children.head, function(node, item, list) {
        if (node.type === &#x27;Comment&#x27;) {
if (!specialComments || node.value.charAt(0) !== &#x27;!&#x27;) {
    list.remove(item);
    return;
}

if (nonSpaceTokenInBuffer || protectedComment) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csso.syntax.List.prototype.prevUntil" id="apidoc.element.csso.syntax.List.prototype.prevUntil">
        function <span class="apidocSignatureSpan">csso.syntax.List.prototype.</span>prevUntil
        <span class="apidocSignatureSpan">(start, fn, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">prevUntil = function (start, fn, context) {
    if (start === null) {
        return;
    }

    var item;

    if (context === undefined) {
        context = this;
    }

    // push cursor
    var cursor = allocateCursor(this, start, null);

    while (cursor.prev !== null) {
        item = cursor.prev;
        cursor.prev = item.prev;

        if (fn.call(context, item.data, item, this)) {
            break;
        }
    }

    // pop cursor
    releaseCursor(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csso.syntax.List.prototype.remove" id="apidoc.element.csso.syntax.List.prototype.remove">
        function <span class="apidocSignatureSpan">csso.syntax.List.prototype.</span>remove
        <span class="apidocSignatureSpan">(item)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">remove = function (item) {
    //      item
    //       ^
    // prev     next
    this.updateCursors(item, item.prev, item, item.next);

    if (item.prev !== null) {
        item.prev.next = item.next;
    } else {
        if (this.head !== item) {
            throw new Error(&#x27;item doesn\&#x27;t below to list&#x27;);
        }

        this.head = item.next;
    }

    if (item.next !== null) {
        item.next.prev = item.prev;
    } else {
        if (this.tail !== item) {
            throw new Error(&#x27;item doesn\&#x27;t below to list&#x27;);
        }

        this.tail = item.prev;
    }

    item.prev = null;
    item.next = null;

    return item;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var buffer = new List();
    var nonSpaceTokenInBuffer = false;
    var protectedComment;

    children.nextUntil(children.head, function(node, item, list) {
        if (node.type === &#x27;Comment&#x27;) {
if (!specialComments || node.value.charAt(0) !== &#x27;!&#x27;) {
    list.<span class="apidocCodeKeywordSpan">remove</span>(item);
    return;
}

if (nonSpaceTokenInBuffer || protectedComment) {
    return true;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csso.syntax.List.prototype.some" id="apidoc.element.csso.syntax.List.prototype.some">
        function <span class="apidocSignatureSpan">csso.syntax.List.prototype.</span>some
        <span class="apidocSignatureSpan">(fn, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">some = function (fn, context) {
    var cursor = this.head;

    if (context === undefined) {
        context = this;
    }

    while (cursor !== null) {
        if (fn.call(context, cursor.data, cursor, this)) {
            return true;
        }

        cursor = cursor.next;
    }

    return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csso.syntax.List.prototype.toArray" id="apidoc.element.csso.syntax.List.prototype.toArray">
        function <span class="apidocSignatureSpan">csso.syntax.List.prototype.</span>toArray
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toArray = function () {
    var cursor = this.head;
    var result = [];

    while (cursor) {
        result.push(cursor.data);
        cursor = cursor.next;
    }

    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csso.syntax.List.prototype.toJSON" id="apidoc.element.csso.syntax.List.prototype.toJSON">
        function <span class="apidocSignatureSpan">csso.syntax.List.prototype.</span>toJSON
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toJSON = function () {
    var cursor = this.head;
    var result = [];

    while (cursor) {
        result.push(cursor.data);
        cursor = cursor.next;
    }

    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csso.syntax.List.prototype.updateCursors" id="apidoc.element.csso.syntax.List.prototype.updateCursors">
        function <span class="apidocSignatureSpan">csso.syntax.List.prototype.</span>updateCursors
        <span class="apidocSignatureSpan">(prevOld, prevNew, nextOld, nextNew)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">updateCursors = function (prevOld, prevNew, nextOld, nextNew) {
    var cursor = this.cursor;

    while (cursor !== null) {
        if (cursor.prev === prevOld) {
            cursor.prev = prevNew;
        }

        if (cursor.next === nextOld) {
            cursor.next = nextNew;
        }

        cursor = cursor.cursor;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.csso.syntax.Tokenizer" id="apidoc.module.csso.syntax.Tokenizer">module csso.syntax.Tokenizer</a></h1>


    <h2>
        <a href="#apidoc.element.csso.syntax.Tokenizer.Tokenizer" id="apidoc.element.csso.syntax.Tokenizer.Tokenizer">
        function <span class="apidocSignatureSpan">csso.syntax.</span>Tokenizer
        <span class="apidocSignatureSpan">(source, startOffset, startLine, startColumn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Tokenizer = function (source, startOffset, startLine, startColumn) {
    this.offsetAndType = null;
    this.lines = null;
    this.columns = null;

    this.setSource(source || &#x27;&#x27;, startOffset, startLine, startColumn);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csso.syntax.Tokenizer.CssSyntaxError" id="apidoc.element.csso.syntax.Tokenizer.CssSyntaxError">
        function <span class="apidocSignatureSpan">csso.syntax.Tokenizer.</span>CssSyntaxError
        <span class="apidocSignatureSpan">(message, source, offset, line, column)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">CssSyntaxError = function (message, source, offset, line, column) {
    var error = new SyntaxError();
    error.name = &#x27;CssSyntaxError&#x27;;
    error.message = message;
    error.source = source;
    error.offset = offset;
    error.line = line;
    error.column = column;

    error.sourceFragment = function(extraLines) {
        return sourceFragment(error, isNaN(extraLines) ? 0 : extraLines);
    };
    Object.defineProperty(error, &#x27;formattedMessage&#x27;, {
        get: function() {
            return (
                &#x27;Parse error: &#x27; + error.message + &#x27;\n&#x27; +
                sourceFragment(error, 2)
            );
        }
    });

    // for backward capability
    error.parseError = {
        offset: offset,
        line: line,
        column: column
    };

    return error;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csso.syntax.Tokenizer.cmpChar" id="apidoc.element.csso.syntax.Tokenizer.cmpChar">
        function <span class="apidocSignatureSpan">csso.syntax.Tokenizer.</span>cmpChar
        <span class="apidocSignatureSpan">(testStr, offset, referenceCode)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function cmpChar(testStr, offset, referenceCode) {
    var code = testStr.charCodeAt(offset);

    // code.toLowerCase()
    if (code &#x3e;= 65 &#x26;&#x26; code &#x3c;= 90) {
        code = code | 32;
    }

    return code === referenceCode;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csso.syntax.Tokenizer.cmpStr" id="apidoc.element.csso.syntax.Tokenizer.cmpStr">
        function <span class="apidocSignatureSpan">csso.syntax.Tokenizer.</span>cmpStr
        <span class="apidocSignatureSpan">(testStr, start, end, referenceStr)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function cmpStr(testStr, start, end, referenceStr) {
    if (end - start !== referenceStr.length) {
        return false;
    }

    if (start &#x3c; 0 || end &#x3e; testStr.length) {
        return false;
    }

    for (var i = start; i &#x3c; end; i++) {
        var testCode = testStr.charCodeAt(i);
        var refCode = referenceStr.charCodeAt(i - start);

        // testStr[i].toLowerCase()
        if (testCode &#x3e;= 65 &#x26;&#x26; testCode &#x3c;= 90) {
            testCode = testCode | 32;
        }

        if (testCode !== refCode) {
            return false;
        }
    }

    return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csso.syntax.Tokenizer.endsWith" id="apidoc.element.csso.syntax.Tokenizer.endsWith">
        function <span class="apidocSignatureSpan">csso.syntax.Tokenizer.</span>endsWith
        <span class="apidocSignatureSpan">(testStr, referenceStr)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function endsWith(testStr, referenceStr) {
    return cmpStr(testStr, testStr.length - referenceStr.length, testStr.length, referenceStr);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csso.syntax.Tokenizer.findCommentEnd" id="apidoc.element.csso.syntax.Tokenizer.findCommentEnd">
        function <span class="apidocSignatureSpan">csso.syntax.Tokenizer.</span>findCommentEnd
        <span class="apidocSignatureSpan">(source, offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function findCommentEnd(source, offset) {
    var commentEnd = source.indexOf(&#x27;*/&#x27;, offset);

    if (commentEnd === -1) {
        return source.length;
    }

    return commentEnd + 2;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csso.syntax.Tokenizer.findDecimalNumberEnd" id="apidoc.element.csso.syntax.Tokenizer.findDecimalNumberEnd">
        function <span class="apidocSignatureSpan">csso.syntax.Tokenizer.</span>findDecimalNumberEnd
        <span class="apidocSignatureSpan">(source, offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function findDecimalNumberEnd(source, offset) {
    for (; offset &#x3c; source.length; offset++) {
        var code = source.charCodeAt(offset);

        if (code &#x3c; 48 || code &#x3e; 57) {  // not a 0 .. 9
            break;
        }
    }

    return offset;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csso.syntax.Tokenizer.findEscaseEnd" id="apidoc.element.csso.syntax.Tokenizer.findEscaseEnd">
        function <span class="apidocSignatureSpan">csso.syntax.Tokenizer.</span>findEscaseEnd
        <span class="apidocSignatureSpan">(source, offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function findEscaseEnd(source, offset) {
    for (var i = 0; i &#x3c; 7 &#x26;&#x26; offset + i &#x3c; source.length; i++) {
        var code = source.charCodeAt(offset + i);

        if (i !== 6 &#x26;&#x26; isHex(code)) {
            continue;
        }

        if (i &#x3e; 0) {
            offset += i - 1 + isNewline(source, offset + i, code);
            if (code === SPACE || code === TAB) {
                offset++;
            }
        }

        break;
    }

    return offset;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csso.syntax.Tokenizer.findIdentifierEnd" id="apidoc.element.csso.syntax.Tokenizer.findIdentifierEnd">
        function <span class="apidocSignatureSpan">csso.syntax.Tokenizer.</span>findIdentifierEnd
        <span class="apidocSignatureSpan">(source, offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function findIdentifierEnd(source, offset) {
    for (; offset &#x3c; source.length; offset++) {
        var code = source.charCodeAt(offset);

        if (code === BACK_SLASH) {
            offset = findEscaseEnd(source, offset + 1);
        } else if (code &#x3c; SYMBOL_TYPE_LENGTH &#x26;&#x26; PUNCTUATION[code] === PUNCTUATOR) {
            break;
        }
    }

    return offset;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csso.syntax.Tokenizer.findLastNonSpaceLocation" id="apidoc.element.csso.syntax.Tokenizer.findLastNonSpaceLocation">
        function <span class="apidocSignatureSpan">csso.syntax.Tokenizer.</span>findLastNonSpaceLocation
        <span class="apidocSignatureSpan">(scanner)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function findLastNonSpaceLocation(scanner) {
    for (var i = scanner.source.length - 1; i &#x3e;= 0; i--) {
        var code = scanner.source.charCodeAt(i);

        if (code !== SPACE &#x26;&#x26; code !== TAB &#x26;&#x26; code !== R &#x26;&#x26; code !== N &#x26;&#x26; code !== F) {
            break;
        }
    }

    return scanner.getLocation(i + 1);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csso.syntax.Tokenizer.findNumberEnd" id="apidoc.element.csso.syntax.Tokenizer.findNumberEnd">
        function <span class="apidocSignatureSpan">csso.syntax.Tokenizer.</span>findNumberEnd
        <span class="apidocSignatureSpan">(source, offset, allowFraction)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function findNumberEnd(source, offset, allowFraction) {
    var code;

    offset = findDecimalNumberEnd(source, offset);

    // fraction: .\d+
    if (allowFraction &#x26;&#x26; offset + 1 &#x3c; source.length &#x26;&#x26; source.charCodeAt(offset) === FULLSTOP) {
        code = source.charCodeAt(offset + 1);

        if (isNumber(code)) {
            offset = findDecimalNumberEnd(source, offset + 1);
        }
    }

    // exponent: e[+-]\d+
    if (offset + 1 &#x3c; source.length) {
        if ((source.charCodeAt(offset) | 32) === E) { // case insensitive check for `e`
            code = source.charCodeAt(offset + 1);

            if (code === PLUSSIGN || code === HYPHENMINUS) {
                if (offset + 2 &#x3c; source.length) {
                    code = source.charCodeAt(offset + 2);
                }
            }

            if (isNumber(code)) {
                offset = findDecimalNumberEnd(source, offset + 2);
            }
        }
    }

    return offset;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csso.syntax.Tokenizer.findStringEnd" id="apidoc.element.csso.syntax.Tokenizer.findStringEnd">
        function <span class="apidocSignatureSpan">csso.syntax.Tokenizer.</span>findStringEnd
        <span class="apidocSignatureSpan">(source, offset, quote)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function findStringEnd(source, offset, quote) {
    for (; offset &#x3c; source.length; offset++) {
        var code = source.charCodeAt(offset);

        // TODO: bad string
        if (code === BACK_SLASH) {
            offset++;
        } else if (code === quote) {
            offset++;
            break;
        }
    }

    return offset;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csso.syntax.Tokenizer.findWhitespaceEnd" id="apidoc.element.csso.syntax.Tokenizer.findWhitespaceEnd">
        function <span class="apidocSignatureSpan">csso.syntax.Tokenizer.</span>findWhitespaceEnd
        <span class="apidocSignatureSpan">(source, offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function findWhitespaceEnd(source, offset) {
    for (; offset &#x3c; source.length; offset++) {
        var code = source.charCodeAt(offset);

        if (code !== SPACE &#x26;&#x26; code !== TAB &#x26;&#x26; code !== R &#x26;&#x26; code !== N &#x26;&#x26; code !== F) {
            break;
        }
    }

    return offset;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csso.syntax.Tokenizer.firstCharOffset" id="apidoc.element.csso.syntax.Tokenizer.firstCharOffset">
        function <span class="apidocSignatureSpan">csso.syntax.Tokenizer.</span>firstCharOffset
        <span class="apidocSignatureSpan">(source)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function firstCharOffset(source) {
    // detect BOM (https://en.wikipedia.org/wiki/Byte_order_mark)
    if (source.charCodeAt(0) === 0xFEFF ||  // UTF-16BE
        source.charCodeAt(0) === 0xFFFE) {  // UTF-16LE
        return 1;
    }

    return 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csso.syntax.Tokenizer.isHex" id="apidoc.element.csso.syntax.Tokenizer.isHex">
        function <span class="apidocSignatureSpan">csso.syntax.Tokenizer.</span>isHex
        <span class="apidocSignatureSpan">(code)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isHex(code) {
    return (code &#x3e;= 48 &#x26;&#x26; code &#x3c;= 57) || // 0 .. 9
           (code &#x3e;= 65 &#x26;&#x26; code &#x3c;= 70) || // A .. F
           (code &#x3e;= 97 &#x26;&#x26; code &#x3c;= 102);  // a .. f
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csso.syntax.Tokenizer.isNewline" id="apidoc.element.csso.syntax.Tokenizer.isNewline">
        function <span class="apidocSignatureSpan">csso.syntax.Tokenizer.</span>isNewline
        <span class="apidocSignatureSpan">(source, offset, code)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isNewline(source, offset, code) {
    if (code === N || code === F || code === R) {
        if (code === R &#x26;&#x26; offset + 1 &#x3c; source.length &#x26;&#x26; source.charCodeAt(offset + 1) === N) {
            return 2;
        }

        return 1;
    }

    return 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csso.syntax.Tokenizer.isNumber" id="apidoc.element.csso.syntax.Tokenizer.isNumber">
        function <span class="apidocSignatureSpan">csso.syntax.Tokenizer.</span>isNumber
        <span class="apidocSignatureSpan">(code)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isNumber(code) {
    return code &#x3e;= 48 &#x26;&#x26; code &#x3c;= 57;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>










</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.csso.syntax.Tokenizer.prototype" id="apidoc.module.csso.syntax.Tokenizer.prototype">module csso.syntax.Tokenizer.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.csso.syntax.Tokenizer.prototype.consume" id="apidoc.element.csso.syntax.Tokenizer.prototype.consume">
        function <span class="apidocSignatureSpan">csso.syntax.Tokenizer.prototype.</span>consume
        <span class="apidocSignatureSpan">(tokenType)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">consume = function (tokenType) {
    var start = this.tokenStart;

    this.eat(tokenType);

    return this.substrToCursor(start);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csso.syntax.Tokenizer.prototype.consumeNonWS" id="apidoc.element.csso.syntax.Tokenizer.prototype.consumeNonWS">
        function <span class="apidocSignatureSpan">csso.syntax.Tokenizer.prototype.</span>consumeNonWS
        <span class="apidocSignatureSpan">(tokenType)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">consumeNonWS = function (tokenType) {
    this.skipWS();

    return this.consume(tokenType);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csso.syntax.Tokenizer.prototype.eat" id="apidoc.element.csso.syntax.Tokenizer.prototype.eat">
        function <span class="apidocSignatureSpan">csso.syntax.Tokenizer.prototype.</span>eat
        <span class="apidocSignatureSpan">(tokenType)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">eat = function (tokenType) {
    if (this.tokenType !== tokenType) {
        this.error(
            NAME[tokenType] + &#x27; is expected&#x27;,
            // when test type is part of another token show error for current position + 1
            // e.g. eat(HYPHENMINUS) will fail on &#x22;-foo&#x22;, but pointing on &#x22;-&#x22; is odd
            this.tokenStart + (this.source.charCodeAt(this.tokenStart) === tokenType ? 1 : 0)
        );
    }

    this.next();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csso.syntax.Tokenizer.prototype.eatNonWS" id="apidoc.element.csso.syntax.Tokenizer.prototype.eatNonWS">
        function <span class="apidocSignatureSpan">csso.syntax.Tokenizer.prototype.</span>eatNonWS
        <span class="apidocSignatureSpan">(tokenType)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">eatNonWS = function (tokenType) {
    this.skipWS();
    this.eat(tokenType);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csso.syntax.Tokenizer.prototype.error" id="apidoc.element.csso.syntax.Tokenizer.prototype.error">
        function <span class="apidocSignatureSpan">csso.syntax.Tokenizer.prototype.</span>error
        <span class="apidocSignatureSpan">(message, offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">error = function (message, offset) {
    var location = typeof offset !== &#x27;undefined&#x27; &#x26;&#x26; offset &#x3c; this.source.length
        ? this.getLocation(offset)
        : this.eof
            ? findLastNonSpaceLocation(this)
            : this.getLocation(this.tokenStart);

    throw new CssSyntaxError(
        message || &#x27;Unexpected input&#x27;,
        this.source,
        location.offset,
        location.line,
        location.column
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csso.syntax.Tokenizer.prototype.expectIdentifier" id="apidoc.element.csso.syntax.Tokenizer.prototype.expectIdentifier">
        function <span class="apidocSignatureSpan">csso.syntax.Tokenizer.prototype.</span>expectIdentifier
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">expectIdentifier = function (name) {
    if (this.tokenType !== IDENTIFIER || cmpStr(this.source, this.tokenStart, this.tokenEnd, name) === false) {
        this.error(&#x27;Identifier `&#x27; + name + &#x27;` is expected&#x27;);
    }

    this.next();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csso.syntax.Tokenizer.prototype.getLocation" id="apidoc.element.csso.syntax.Tokenizer.prototype.getLocation">
        function <span class="apidocSignatureSpan">csso.syntax.Tokenizer.prototype.</span>getLocation
        <span class="apidocSignatureSpan">(offset, filename)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getLocation = function (offset, filename) {
    if (!this.linesAnsColumnsComputed) {
        computeLinesAndColumns(this, this.source);
    }

    return {
        source: filename,
        offset: this.startOffset + offset,
        line: this.lines[offset],
        column: this.columns[offset]
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csso.syntax.Tokenizer.prototype.getLocationRange" id="apidoc.element.csso.syntax.Tokenizer.prototype.getLocationRange">
        function <span class="apidocSignatureSpan">csso.syntax.Tokenizer.prototype.</span>getLocationRange
        <span class="apidocSignatureSpan">(start, end, filename)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getLocationRange = function (start, end, filename) {
    if (!this.linesAnsColumnsComputed) {
        computeLinesAndColumns(this, this.source);
    }

    return {
        source: filename,
        start: {
            offset: this.startOffset + start,
            line: this.lines[start],
            column: this.columns[start]
        },
        end: {
            offset: this.startOffset + end,
            line: this.lines[end],
            column: this.columns[end]
        }
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csso.syntax.Tokenizer.prototype.getTokenValue" id="apidoc.element.csso.syntax.Tokenizer.prototype.getTokenValue">
        function <span class="apidocSignatureSpan">csso.syntax.Tokenizer.prototype.</span>getTokenValue
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getTokenValue = function () {
    return this.source.substring(this.tokenStart, this.tokenEnd);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csso.syntax.Tokenizer.prototype.getTypes" id="apidoc.element.csso.syntax.Tokenizer.prototype.getTypes">
        function <span class="apidocSignatureSpan">csso.syntax.Tokenizer.prototype.</span>getTypes
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getTypes = function () {
    return Array.prototype.slice.call(this.offsetAndType, 0, this.tokenCount).map(function(item) {
        return NAME[item &#x3e;&#x3e; TYPE_OFFSET];
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csso.syntax.Tokenizer.prototype.lookupNonWSType" id="apidoc.element.csso.syntax.Tokenizer.prototype.lookupNonWSType">
        function <span class="apidocSignatureSpan">csso.syntax.Tokenizer.prototype.</span>lookupNonWSType
        <span class="apidocSignatureSpan">(offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lookupNonWSType = function (offset) {
    offset += this.currentToken;

    for (var type; offset &#x3c; this.tokenCount; offset++) {
        type = this.offsetAndType[offset] &#x3e;&#x3e; TYPE_OFFSET;

        if (type !== WHITESPACE) {
            return type;
        }
    }

    return NULL;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csso.syntax.Tokenizer.prototype.lookupType" id="apidoc.element.csso.syntax.Tokenizer.prototype.lookupType">
        function <span class="apidocSignatureSpan">csso.syntax.Tokenizer.prototype.</span>lookupType
        <span class="apidocSignatureSpan">(offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lookupType = function (offset) {
    offset += this.currentToken;

    if (offset &#x3c; this.tokenCount) {
        return this.offsetAndType[offset] &#x3e;&#x3e; TYPE_OFFSET;
    }

    return NULL;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csso.syntax.Tokenizer.prototype.lookupValue" id="apidoc.element.csso.syntax.Tokenizer.prototype.lookupValue">
        function <span class="apidocSignatureSpan">csso.syntax.Tokenizer.prototype.</span>lookupValue
        <span class="apidocSignatureSpan">(offset, referenceStr)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lookupValue = function (offset, referenceStr) {
    offset += this.currentToken;

    if (offset &#x3c; this.tokenCount) {
        return cmpStr(
            this.source,
            this.offsetAndType[offset - 1] &#x26; OFFSET_MASK,
            this.offsetAndType[offset] &#x26; OFFSET_MASK,
            referenceStr
        );
    }

    return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csso.syntax.Tokenizer.prototype.next" id="apidoc.element.csso.syntax.Tokenizer.prototype.next">
        function <span class="apidocSignatureSpan">csso.syntax.Tokenizer.prototype.</span>next
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">next = function () {
    var next = this.currentToken + 1;

    if (next &#x3c; this.tokenCount) {
        this.currentToken = next;
        this.tokenStart = this.tokenEnd;
        next = this.offsetAndType[next];
        this.tokenType = next &#x3e;&#x3e; TYPE_OFFSET;
        this.tokenEnd = next &#x26; OFFSET_MASK;
    } else {
        this.currentToken = this.tokenCount;
        this.eof = true;
        this.tokenType = NULL;
        this.tokenStart = this.tokenEnd = this.source.length;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csso.syntax.Tokenizer.prototype.setSource" id="apidoc.element.csso.syntax.Tokenizer.prototype.setSource">
        function <span class="apidocSignatureSpan">csso.syntax.Tokenizer.prototype.</span>setSource
        <span class="apidocSignatureSpan">(source, startOffset, startLine, startColumn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setSource = function (source, startOffset, startLine, startColumn) {
    var start = firstCharOffset(source);

    this.source = source;
    this.startOffset = typeof startOffset === &#x27;undefined&#x27; ? 0 : startOffset;
    this.startLine = typeof startLine === &#x27;undefined&#x27; ? 1 : startLine;
    this.startColumn = typeof startColumn === &#x27;undefined&#x27; ? 1 : startColumn;
    this.linesAnsColumnsComputed = false;

    this.eof = false;
    this.currentToken = -1;
    this.tokenType = 0;
    this.tokenStart = start;
    this.tokenEnd = start;

    tokenLayout(this, source, start);
    this.next();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csso.syntax.Tokenizer.prototype.skip" id="apidoc.element.csso.syntax.Tokenizer.prototype.skip">
        function <span class="apidocSignatureSpan">csso.syntax.Tokenizer.prototype.</span>skip
        <span class="apidocSignatureSpan">(tokenCount)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">skip = function (tokenCount) {
    var next = this.currentToken + tokenCount;

    if (next &#x3c; this.tokenCount) {
        this.currentToken = next;
        this.tokenStart = this.offsetAndType[next - 1] &#x26; OFFSET_MASK;
        next = this.offsetAndType[next];
        this.tokenType = next &#x3e;&#x3e; TYPE_OFFSET;
        this.tokenEnd = next &#x26; OFFSET_MASK;
    } else {
        this.currentToken = this.tokenCount;
        this.next();
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csso.syntax.Tokenizer.prototype.skipSC" id="apidoc.element.csso.syntax.Tokenizer.prototype.skipSC">
        function <span class="apidocSignatureSpan">csso.syntax.Tokenizer.prototype.</span>skipSC
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">skipSC = function () {
    while (this.tokenType === WHITESPACE || this.tokenType === COMMENT) {
        this.next();
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csso.syntax.Tokenizer.prototype.skipWS" id="apidoc.element.csso.syntax.Tokenizer.prototype.skipWS">
        function <span class="apidocSignatureSpan">csso.syntax.Tokenizer.prototype.</span>skipWS
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">skipWS = function () {
    for (var i = this.currentToken, skipTokenCount = 0; i &#x3c; this.tokenCount; i++, skipTokenCount++) {
        if ((this.offsetAndType[i] &#x3e;&#x3e; TYPE_OFFSET) !== WHITESPACE) {
            break;
        }
    }

    if (skipTokenCount &#x3e; 0) {
        this.skip(skipTokenCount);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.csso.syntax.Tokenizer.prototype.substrToCursor" id="apidoc.element.csso.syntax.Tokenizer.prototype.substrToCursor">
        function <span class="apidocSignatureSpan">csso.syntax.Tokenizer.prototype.</span>substrToCursor
        <span class="apidocSignatureSpan">(start)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">substrToCursor = function (start) {
    return this.source.substring(start, this.tokenStart);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.csso.syntax.syntax" id="apidoc.module.csso.syntax.syntax">module csso.syntax.syntax</a></h1>


    <h2>
        <a href="#apidoc.element.csso.syntax.syntax.Lexer" id="apidoc.element.csso.syntax.syntax.Lexer">
        function <span class="apidocSignatureSpan">csso.syntax.syntax.</span>Lexer
        <span class="apidocSignatureSpan">(config, syntax, structure)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Lexer = function (config, syntax, structure) {
    this.valueCommonSyntax = cssWideKeywords;
    this.syntax = syntax;
    this.generic = false;
    this.properties = {};
    this.types = {};
    this.structure = structure;

    if (config) {
        if (config.generic) {
            this.generic = true;
            for (var name in generic) {
                this.addType_(name, generic[name]);
            }
        }

        if (config.types) {
            for (var name in config.types) {
                this.addType_(name, config.types[name]);
            }
        }

        if (config.properties) {
            for (var name in config.properties) {
                this.addProperty_(name, config.properties[name]);
            }
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.csso.usage" id="apidoc.module.csso.usage">module csso.usage</a></h1>


    <h2>
        <a href="#apidoc.element.csso.usage.buildIndex" id="apidoc.element.csso.usage.buildIndex">
        function <span class="apidocSignatureSpan">csso.usage.</span>buildIndex
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function buildIndex(data) {
    var scopes = false;

    if (data.scopes &#x26;&#x26; Array.isArray(data.scopes)) {
        scopes = Object.create(null);

        for (var i = 0; i &#x3c; data.scopes.length; i++) {
            var list = data.scopes[i];

            if (!list || !Array.isArray(list)) {
                throw new Error(&#x27;Wrong usage format&#x27;);
            }

            for (var j = 0; j &#x3c; list.length; j++) {
                var name = list[j];

                if (hasOwnProperty.call(scopes, name)) {
                    throw new Error(&#x27;Class can\&#x27;t be used for several scopes: &#x27; + name);
                }

                scopes[name] = i + 1;
            }
        }
    }

    return {
        tags: buildMap(data.tags, true),
        ids: buildMap(data.ids),
        classes: buildMap(data.classes),
        scopes: scopes
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
inputRules = ast.children;
ast.children = outputRules;
    } else {
inputRules = wrapBlock(ast);
    }

    if (options.usage) {
usageData = usageUtils.<span class="apidocCodeKeywordSpan">buildIndex</span>(options.usage);
    }

    do {
chunk = readChunk(inputRules, Boolean(specialComments));

compressChunk(chunk.stylesheet, firstAtrulesAllowed, usageData, chunkNum++, logger);
...</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
